% 2015-09-09
\documentclass[12pt]{report}
%\usepackage{extsizes}
%\usepackage[letterpaper, margin=2.44cm]{geometry}
\usepackage[letterpaper, margin=2.54cm]{geometry}
\usepackage{parskip}
\usepackage[super]{nth}
\usepackage{xspace}
\setlength{\parskip}{0cm}
%\setlength{\headheight}{0cm}
\usepackage{setspace}
%single-spaced?
\linespread{1}
%\double-spaced?
%\linespread{1.9}
\usepackage{times}
\usepackage[none]{hyphenat}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{\thepage}
\lfoot{}
\cfoot{}
\rfoot{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\newcommand*\elide{\textup{[\,\dots]}\xspace}
% Additional distance from the top of the page. 12pt -> 4.23mm, so 12.7mm - 4.23mm = 8.47mm
%\setlength\headsep{8.47mm}
\setlength\headsep{4.23mm}
\begin{document}
\begin{flushleft}
%``double_quote''
%`single_quote'
%\setlength{\parindent}{0cm}

\begin{center}
Project Title (tentative): Ventilate
\end{center}

\setlength{\parindent}{1.27cm}

\indent \indent Our team of five is developing a chat room based program, borrowing some elements of the design of IRC clients, many examples of which can be commonly found. Our program is designed to be compatible with a variety of different platforms, but we will specifically be targeting the Mac OS X, Linux and Windows environments for compatibility when compiling binary executable files from our source code. Our primary development languages will be C and C++, especially in light of our group having chosen Qt for our preferred graphics toolset. This is a cross-platform and well-documented library designed for development with C++, which suits our needs appropriately. This is especially important because one of our primary goals is excellent cross-platform compatibility, which can be best facilitated by our choosing a suitable library and programming language ahead of time.

\indent Our primary risks will likely involve communications and equipment problems, along with personnel issues like a lack of familiarity with some of the technologies which we use, and running afoul of network policies with the the Computer Science and Engineering (CSE) servers run by the University of North Texas (UNT). One of the technical issues which we may find ourselves confronting is trouble with the complexity of the connections density with many users connected at once. This is a problem because the total number of bidirectional edges for a complete graph (which our system closely models in theory) is \(\frac{(n)(n-1)}{2}\) (where \(n\) represents the number of users connected), which has a Big-O complexity of \(O(n\textsuperscript{2})\). Our choice of networking protocol is part of our solution to this; the number of other users for any given user to query any time, for example, a log file needs to be updated, is simply \((n-1)\), which has a Big-O complexity instead of \(O(n)\). If we were to have chosen instead a completely client/server-based model, the server would have become increasingly laden with overly-complex sets of network links about which to remain updated, which would have negatively affected the performance of our application when scaling to especially large numbers of users over extended periods of time.

\indent Our focus regarding communication protocol is on peer-to-peer networking with connected clients. This presents a practical benefit in that very little interaction is required with a complex central server. The program will still require some measure of interaction with a basic server, mainly for Internet Protocol (IP) address translation and in order to authenticate clients, but this can be served by a simpler program running on a system with a known IP address. This is similar in practice to tracker servers from the BitTorrent protocol, and indeed serves the similar function of facilitating connections between active peers. Two of our main goals are security and distributed networking, which informs our decision to keep the server's functionality as minimal as possible. Whenever the program is started and a user is successfully authenticated, they are automatically entered into a central, ``skeleton'' chat room which displays connected users. Practically, this will involve querying the server for active users and their IP addresses, and then the client program establishing connections to each peer. Activity thereafter is restricted to peer-based communication, and this is notably the case both for establishing chat rooms and for maintaining records of chat activity. One of the main activities of the serer will be to act as a sort of DNS lookup, keeping track of the most previous IP address which each individual user last used to log in with the client and updating this accordingly. When a new user connects, the servers pings all users already present with the new user's IP address, which they use to establish a connection with the new user. The new user sends a query to the server likewise for the IP addresses of all users already present, and establishes connections with them individually. A consequence of this design is that multiple simultaneous logins will not be possible for any given user; usernames can only be in use on one system at a time, which the server's authentication system enforces. In the case that several users enter the system at once, the server queues several new IP addresses to existing users, for them to connect to. Once all users have a list of connections equal in length to the size of the initial chat ``room'' minus one (to account for themselves), the new user is successfully integrated, and is ready to proceed to updating their copy of chat history.

\indent Users are authenticated with a password-based hash system. The client application first requests a password string from the user at login. Then, a hash key is generated from this string and sent to the server, along with another has value generated from the user's account name. The server will store a simple associative list of these two keys, and checks for a match. If a match is not found, the user may try a fixed number of times before the server enforces a penalty for wrong password tries (a delay). The possibility of hash collisions is remote but real; at account creation, the server will scan the internal list for the generated hash value, and request a new username if a match is found. This same process is repeated when the user chooses a password. Passwords remain fixed until a user requests a change, at which point they must first enter their current password before providing a new one, which is hashed appropriately on success.%forgotten passwords?

\indent Chat rooms are established either when a user invites another user to join a chat room, or are broadcast publicly. Using the list from the skeleton room which they initially entered, users can invite others to join a private chat room, and this private "tag" establishes visibility and accessibility for other users. Public rooms are broadcast to all other users, and once opened can be entered without an invitation. These chat rooms persist even when the user which opened them leaves the room, but are closed when the last user present disconnects (as do all chat rooms). Chat logs are updated to connected clients every fixed amount of time while the room is opened, and when the room finally closes the last user connected updates the previous version on the server. Because logs from the past will not change, ``diff'' files can be uploaded which do not require increasingly long copies (as part of their design).

\indent Chat history for public rooms is stored locally in a compressed plain-text format, on the systems of every client machine which has entered that room, but a copy is also mirrored to the server whenever a given chat room is closed. The server additionally holds an encrypted log of the names of all chat room which each user has visited, which allows for chat history to be updated even on machines where the user has never run the client application before. When a user logs in on any system, the program runs a check for  the names of chat room logs where they should be stored, and checks the names against those associated with the user's account. If any are missing then client will query the other users currently present, and if none of them have the logs available then the server will provide the client with a full copy of the logs. Chat history for private chat rooms is stored in a similar manner to the lists of chat rooms which users have visited, namely encrypted and uniquely to each user. Beyond this, private chat logs are served and updated in the same manner as those for public chat rooms. Notably, this includes un-encrypted, plain-text copies kept locally. This is not a security concern because any user which connects will have already had access; the added security on the server furthers the aim of private chat rooms approximating private messaging services, and indeed prevents anybody with server access from accessing these logs. A potential complication of providing access to chat logs over time is that of excessive disk space usage on the server. It is not clear just how much space we will have available, nor how well such an amount of space will be able to maintain our system over time, but should this become a significant issue the solution will likely be to implement some sort of queue on the server and the clients, where logs which are over a certain size or older than a particular age are truncated to reasonable levels.

\end{flushleft}
\end{document}
\}